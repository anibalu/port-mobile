diff --git a/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/RNCallKeepModule.java b/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/RNCallKeepModule.java
index 025480a..ecd20cb 100644
--- a/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/RNCallKeepModule.java
+++ b/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/RNCallKeepModule.java
@@ -72,6 +72,8 @@ import com.facebook.react.modules.permissions.PermissionsModule;
 import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Set;
+import java.util.HashSet;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -434,10 +436,10 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule implements Life
         this.hasListeners = false;
     }
 
-    @ReactMethod
-    public void displayIncomingCall(String uuid, String number, String callerName) {
-        this.displayIncomingCall(uuid, number, callerName, false, null);
-    }
+    // @ReactMethod
+    // public void displayIncomingCall(String uuid, String number, String callerName) {
+    //     this.displayIncomingCall(uuid, number, callerName, false, null);
+    // }
 
     @ReactMethod
     public void displayIncomingCall(String uuid, String number, String callerName, boolean hasVideo) {
@@ -483,10 +485,10 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule implements Life
         conn.onAnswer();
     }
 
-    @ReactMethod
-    public void startCall(String uuid, String number, String callerName) {
-        this.startCall(uuid, number, callerName, false, null);
-    }
+    // @ReactMethod
+    // public void startCall(String uuid, String number, String callerName) {
+    //     this.startCall(uuid, number, callerName, false, null);
+    // }
 
     @ReactMethod
     public void startCall(String uuid, String number, String callerName, boolean hasVideo) {
@@ -828,87 +830,182 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule implements Life
     }
 
     @ReactMethod
-    public void setAudioRoute(String uuid, String audioRoute, Promise promise){
+    public void setAudioRoute(String uuid, String audioRoute, Promise promise) {
         try {
-            VoiceConnection conn = (VoiceConnection) VoiceConnectionService.getConnection(uuid);
-            if (conn == null) {
+            Log.d(TAG, "[RNCallKeepModule] setAudioRoute, uuid: " + uuid + ", audioRoute: " + audioRoute);
+            Context context = this.getAppContext();
+            if (context == null) {
+                Log.w(TAG, "[RNCallKeepModule][setAudioRoute] No React context found.");
+                promise.reject("No React context found to set audio route");
                 return;
             }
-            if(audioRoute.equals("Bluetooth")) {
-                Log.d(TAG,"[RNCallKeepModule] setting audio route: Bluetooth");
-                conn.setAudioRoute(CallAudioState.ROUTE_BLUETOOTH);
-                promise.resolve(true);
+            AudioManager audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
+            if (audioManager == null) {
+                Log.w(TAG, "[RNCallKeepModule][setAudioRoute] AudioManager is null.");
+                promise.reject("AudioManager is null");
                 return;
             }
-            if(audioRoute.equals("Headset")) {
-                Log.d(TAG,"[RNCallKeepModule] setting audio route: Headset");
-                conn.setAudioRoute(CallAudioState.ROUTE_WIRED_HEADSET);
-                promise.resolve(true);
-                return;
+
+            // First reset all audio routes
+            audioManager.setSpeakerphoneOn(false);
+            audioManager.setBluetoothScoOn(false);
+            if (audioManager.isBluetoothScoAvailableOffCall()) {
+                audioManager.stopBluetoothSco();
             }
-            if(audioRoute.equals("Speaker")) {
-                Log.d(TAG,"[RNCallKeepModule] setting audio route: Speaker");
-                conn.setAudioRoute(CallAudioState.ROUTE_SPEAKER);
-                promise.resolve(true);
-                return;
+
+            // Set audio mode for call
+            audioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);
+
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) { // API 31+
+                List<AudioDeviceInfo> devices = audioManager.getAvailableCommunicationDevices();
+                AudioDeviceInfo targetDevice = null;
+
+                for (AudioDeviceInfo device : devices) {
+                    if (audioRoute.equalsIgnoreCase("Bluetooth") &&
+                        (device.getType() == AudioDeviceInfo.TYPE_BLUETOOTH_SCO ||
+                         device.getType() == AudioDeviceInfo.TYPE_BLUETOOTH_A2DP ||
+                         device.getType() == AudioDeviceInfo.TYPE_BLE_HEADSET)) {
+                        targetDevice = device;
+                        break;
+                    } else if (audioRoute.equalsIgnoreCase("Headset") &&
+                               (device.getType() == AudioDeviceInfo.TYPE_WIRED_HEADPHONES ||
+                                device.getType() == AudioDeviceInfo.TYPE_WIRED_HEADSET)) {
+                        targetDevice = device;
+                        break;
+                    } else if (audioRoute.equalsIgnoreCase("Speaker") &&
+                               device.getType() == AudioDeviceInfo.TYPE_BUILTIN_SPEAKER) {
+                        targetDevice = device;
+                        break;
+                    } else if (audioRoute.equalsIgnoreCase("Phone") &&
+                               device.getType() == AudioDeviceInfo.TYPE_BUILTIN_EARPIECE) {
+                        targetDevice = device;
+                        break;
+                    }
+                }
+
+                if (targetDevice != null) {
+                    audioManager.clearCommunicationDevice();
+                    boolean result = audioManager.setCommunicationDevice(targetDevice);
+                    if (result) {
+                        promise.resolve(true);
+                    } else {
+                        Log.e(TAG, "[RNCallKeepModule] Failed to set communication device.");
+                        // Fallback to legacy method if setting device fails
+                        setLegacyAudioRoute(audioManager, audioRoute, promise);
+                    }
+                } else {
+                    // Fallback to legacy method if device not found
+                    setLegacyAudioRoute(audioManager, audioRoute, promise);
+                }
+            } else {
+                // For older Android versions
+                setLegacyAudioRoute(audioManager, audioRoute, promise);
             }
-            Log.d(TAG,"[RNCallKeepModule] setting audio route: Wired/Earpiece");
-            conn.setAudioRoute(CallAudioState.ROUTE_WIRED_OR_EARPIECE);
-            promise.resolve(true);
         } catch (Exception e) {
-            promise.reject("SetAudioRoute", e.getMessage());
+            Log.e(TAG, "[RNCallKeepModule] Error setting audio route", e);
+            promise.reject("SetAudioRoute Error", e.getMessage());
         }
     }
 
-    @ReactMethod
-    public void getAudioRoutes(Promise promise){
+    private void setLegacyAudioRoute(AudioManager audioManager, String audioRoute, Promise promise) {
         try {
-            Context context = this.getAppContext();
-            if (context == null) {
-                Log.w(TAG, "[RNCallKeepModule][getAudioRoutes] no react context found.");
-                promise.reject("No react context found to list audio routes");
-                return;
+            switch (audioRoute.toLowerCase()) {
+                case "bluetooth":
+                    if (audioManager.isBluetoothScoAvailableOffCall()) {
+                        audioManager.startBluetoothSco();
+                        audioManager.setBluetoothScoOn(true);
+                    }
+                    break;
+                case "speaker":
+                    audioManager.setSpeakerphoneOn(true);
+                    break;
+                case "phone":
+                    // Default earpiece
+                    audioManager.setSpeakerphoneOn(false);
+                    audioManager.setBluetoothScoOn(false);
+                    break;
+                case "headset":
+                    // For wired headset, just ensure speaker and bluetooth are off
+                    audioManager.setSpeakerphoneOn(false);
+                    audioManager.setBluetoothScoOn(false);
+                    break;
             }
-            AudioManager audioManager = (AudioManager) context.getSystemService(context.AUDIO_SERVICE);
-            WritableArray devices = Arguments.createArray();
-            ArrayList<String> typeChecker = new ArrayList<>();
-            AudioDeviceInfo[] audioDeviceInfo = audioManager.getDevices(AudioManager.GET_DEVICES_INPUTS + AudioManager.GET_DEVICES_OUTPUTS);
-            String selectedAudioRoute = getSelectedAudioRoute(audioManager);
-            for (AudioDeviceInfo device : audioDeviceInfo){
-                String type = getAudioRouteType(device.getType());
-                if(type != null && !typeChecker.contains(type)) {
+            promise.resolve(true);
+        } catch (Exception e) {
+            Log.e(TAG, "[RNCallKeepModule] Error in legacy audio route", e);
+            promise.reject("SetLegacyAudioRoute Error", e.getMessage());
+        }
+    }
+
+    @ReactMethod
+    public void getAudioRoutes(Promise promise) {
+    try {
+        Context context = this.getAppContext();
+        if (context == null) {
+            Log.w(TAG, "[RNCallKeepModule][getAudioRoutes] No React context found.");
+            promise.reject("No React context found to list audio routes");
+            return;
+        }
+        AudioManager audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
+        if (audioManager == null) {
+            Log.w(TAG, "[RNCallKeepModule][getAudioRoutes] AudioManager is null.");
+            promise.reject("AudioManager is null");
+            return;
+        }
+
+        WritableArray devices = Arguments.createArray();
+        Set<String> typeChecker = new HashSet<>();
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) { // API 31
+            List<AudioDeviceInfo> audioDeviceInfos = audioManager.getAvailableCommunicationDevices();
+            AudioDeviceInfo selectedDevice = audioManager.getCommunicationDevice();
+            String selectedAudioRoute = getAudioRouteType(selectedDevice);
+
+            for (AudioDeviceInfo device : audioDeviceInfos) {
+                String type = getAudioRouteType(device);
+                if (type != null && typeChecker.add(type)) {
                     WritableMap deviceInfo = Arguments.createMap();
-                    deviceInfo.putString("name",  type);
-                    deviceInfo.putString("type",  type);
-                    if(type.equals(selectedAudioRoute)) {
-                        deviceInfo.putBoolean("selected",  true);
-                    }
-                    typeChecker.add(type);
+                    deviceInfo.putString("name", type);
+                    deviceInfo.putString("type", type);
+                    deviceInfo.putBoolean("selected", type.equals(selectedAudioRoute));
                     devices.pushMap(deviceInfo);
                 }
             }
-            promise.resolve(devices);
-        } catch(Exception e) {
+            Log.d(TAG, "[RNCallKeepModule] getAvailableCommunicationDevices result: " + audioDeviceInfos.toString());
+        } else {
+            Log.w(TAG, "[RNCallKeepModule] getAvailableCommunicationDevices requires API level 31 or higher.");
+            promise.reject("getAvailableCommunicationDevices requires API level 31 or higher");
+        }
+
+        promise.resolve(devices);
+    } catch (Exception e) {
+            Log.e(TAG, "[RNCallKeepModule][getAudioRoutes] Error retrieving audio routes", e);
             promise.reject("GetAudioRoutes Error", e.getMessage());
         }
     }
 
-    private String getAudioRouteType(int type){
-        switch (type){
-            case(AudioDeviceInfo.TYPE_BLUETOOTH_A2DP):
-            case(AudioDeviceInfo.TYPE_BLUETOOTH_SCO):
-                return "Bluetooth";
-            case(AudioDeviceInfo.TYPE_WIRED_HEADPHONES):
-            case(AudioDeviceInfo.TYPE_WIRED_HEADSET):
-                return "Headset";
-            case(AudioDeviceInfo.TYPE_BUILTIN_MIC):
-                return "Phone";
-            case(AudioDeviceInfo.TYPE_BUILTIN_SPEAKER):
-                return "Speaker";
-            default:
-                return null;
-        }
+
+    private String getAudioRouteType(AudioDeviceInfo device) {
+    if (device == null) {
+        return null;
     }
+    switch (device.getType()) {
+        case AudioDeviceInfo.TYPE_BLUETOOTH_SCO:
+        case AudioDeviceInfo.TYPE_BLUETOOTH_A2DP:
+        case AudioDeviceInfo.TYPE_BLE_HEADSET:
+            return "Bluetooth";
+        case AudioDeviceInfo.TYPE_WIRED_HEADPHONES:
+        case AudioDeviceInfo.TYPE_WIRED_HEADSET:
+            return "Headset";
+        case AudioDeviceInfo.TYPE_BUILTIN_SPEAKER:
+            return "Speaker";
+        case AudioDeviceInfo.TYPE_BUILTIN_EARPIECE:
+            return "Phone";
+        default:
+            return null;
+    }
+    }
+
 
     private String getSelectedAudioRoute(AudioManager audioManager){
         if(audioManager.isBluetoothScoOn()){
